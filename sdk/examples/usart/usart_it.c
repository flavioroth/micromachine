
#include <stdint.h>
#include <stdbool.h>
#include <control_registers.h>
#include <system.h>
#include <stdlib.h>
#include <stdio.h>
#include <micromachine.h>

// Fwd declaration
struct usart_device;

/**
 * This callback is used when the usart_transmit_async is terminated.
 */
typedef void (*xfer_completed_cb)(struct usart_device* dev, int status);

struct usart_config {
	bool enable;
	// Future config will be abstracted where (baud rate, parity, stop/start bits ...)
};

struct usart_device {
	USART_TypeDef* port;
	struct usart_config conf;

	uint8_t *tx_data;
	size_t tx_len;
	xfer_completed_cb cb; // call when usart_transmit_async is terminated, the callback is called during usart isr
	void* user_data;
};

/**
 * Signal to the main task transfer completion
 * Called in a interrupt context
 */
void xfer_complete(struct usart_device* dev, int status) {
	*(int*)(dev->user_data) = 0x55;
}

int usart_init(struct usart_device* dev) {
	MODIFY_REG(dev->port->CR1, USART_CR1_UE, dev->conf.enable);
	return 0;
}

int usart_deinit(struct usart_device* dev) {
	CLEAR_BIT(dev->port->CR1, USART_CR1_UE);
	return 0;
}

void usart_transmit_async(struct usart_device* dev, uint8_t* data, size_t len) {

	dev->tx_data = data;
	dev->tx_len = len;

	// enable  Tx empty interrupt (should raise an interrupt if tx is empty)
	SET_BIT(dev->port->CR1, USART_CR1_TXE);

	// Enable USART_IRQ, will be disabled in usart_end_transmit_it
	NVIC_EnableIRQ(USART_IRQn);
}

// shared data between isr and main task
static int dummy = 42;
static struct usart_device dev = {
	.port = USART0,
	.conf =
		{
			.enable = true,
		},
	.cb = xfer_complete,
	.user_data = &dummy,
};

static void usart_transmit_it(struct usart_device* dev) {

	size_t transmitted = 0;
	while(transmitted < dev->tx_len) {
		dev->port->TX = dev->tx_data[transmitted];
		transmitted++;
	}

	// disable tx empty interrupt
	CLEAR_BIT(dev->port->CR1, USART_CR1_TXE);

	// enable tx complete interrupt
	SET_BIT(dev->port->CR1, USART_CR1_TXC);
}

static void usart_end_transmit_it(struct usart_device* dev) {

	// disable tx complete interrupt
	CLEAR_BIT(dev->port->CR1, USART_CR1_TXC);

	// clear tx empty interrupt status
	SET_BIT(dev->port->ICR, USART_ICR_TXC);

	// Signal user xfer is completed
	if(dev->cb) {
		dev->cb(dev, 0);
	}

	NVIC_DisableIRQ(USART_IRQn);
}

void _isr_usart() {
	uint32_t isr_flags = USART0->ISR;
	uint32_t cr1_flags = USART0->CR1;

	if((isr_flags & USART_ISR_TXE) && (cr1_flags & USART_CR1_TXE)) {
		usart_transmit_it(&dev);
		return;
	}

	if((isr_flags & USART_ISR_TXC) && (cr1_flags & USART_CR1_TXC)) {
		usart_end_transmit_it(&dev);
		return;
	}
}

static void wait_xfer_is_completed() {
	printf("[+] Transfer in progress...\n");
	while(*(int*)(dev.user_data) != 0x55);
	printf("[+] Transfer is done!\n");
}

static void tx_example() {
	uint8_t data[] = "Hello usart world!\n";
	usart_transmit_async(&dev, data, sizeof(data) - 1);
	wait_xfer_is_completed();
}

static uint8_t usart_read() {
	SET_BIT(dev.port->CR1, USART_CR1_RXNE);
	// Wait RX is fullfilled, it could be coupled with timeout..
	while((dev.port->ISR & USART_ISR_RXNE) == 0);

	CLEAR_BIT(dev.port->ICR, USART_ICR_RXNE);
	uint32_t rx_data = dev.port->RX;
	return (uint8_t)(rx_data & 0xFFu);
}

static void rx_example() {
	unsigned int len = 20;
	printf("[+] Data received : '");
	while(len--) {
		uint8_t rx_data = usart_read();
		printf("%c", rx_data);
	}
	printf("'\n");
}

int main() {
	usart_init(&dev);

	/*
	 * Asynchronous example, data will be forwarded to stdout in the vm
	 */
	tx_example();

	/*
	 * Blocking read, data are generated by the vm
	 */
	rx_example();

	usart_deinit(&dev);
}
